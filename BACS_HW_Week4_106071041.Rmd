---
title: "BASC HW Week4 106071041"
output:
  word_document: default
  html_notebook: default
  pdf_document: default
  html_document:
    df_print: paged
---
# Question 1 | Standardize the data

### (a) rnorm(mean=940, sd=190) and standardize it
```{r}
# Create a data
nd <- rnorm(1000, 940, 190)
```
```{r}
# Standardize
rnorm_std <- (nd-mean(nd))/sd(nd)
```

#### (i) Expected mean and standard deviation of rnorm_std and why  

mean = 0 and standard deviation = 1.  
"Standardized" means make the mean and standard deviation respectively become 0 and 1.    

```{r}
# make 1+15e -> 1000000000000...
options(scipen = 999)
```

```{r}
mean(rnorm_std)
sd(rnorm_std)
```

#### (ii) The look of the distribution of rnorm_std and why  
Bell-shaped.  
That is how standard normal distribution looks like.  

#### (iii) distributions that are normal and standardized?  
Standard normal distribution.  

### (b) standardized version of minday
```{r}
bookings <- read.table("first_bookings_datetime_sample.txt", header=TRUE)
bookings$datetime[1:9]
hours  <- as.POSIXlt(bookings$datetime, format="%m/%d/%Y %H:%M")$hour
mins   <- as.POSIXlt(bookings$datetime, format="%m/%d/%Y %H:%M")$min
minday <- hours*60 + mins
plot(density(minday), main="Minute (of the day) of first ever booking", col="blue", lwd=2)
```
```{r}
minday_std <- (minday - mean(minday))/sd(minday)
```

#### (i) expected mean and standard deviation of minday_std and why  
mean = 0 and standard deviation = 1.  
"Standardized" means make the mean and standard deviation respectively become 0 and 1.    
```{r}
options(scipen = 999)
```
```{r}
mean(minday_std)
```
```{r}
sd(minday_std)
```

#### (ii) the look of the distribution of minday_std compared to minday, and why  
looks similar.  
minday is not normally distributed so will minday_std.  

```{r}
plot(density(minday))
```
```{r}
plot(density(minday_std))
```

# Question 2 | Simulations  

### (a) Simulate 100 samples (each of size 100), from a normally distributed population of 10,000
```{r}
visualize_sample_ci <- function(num_samples = 100, sample_size = 100, 
                                pop_size=10000, distr_func, ...) {
  # Simulate a large population
  population_data <- distr_func(pop_size, ...)
  pop_mean <- mean(population_data)
  pop_sd <- sd(population_data)
  
  # Simulate samples
  samples <- replicate(num_samples, 
                       sample(population_data, sample_size, replace=FALSE))
  
  # Calculate descriptives of samples
  sample_means = apply(samples, 2, FUN=mean)
  sample_stdevs = apply(samples, 2, FUN=sd)
  sample_stderrs <- sample_stdevs/sqrt(sample_size)
  ci95_low  <- sample_means - sample_stderrs*1.96
  ci95_high <- sample_means + sample_stderrs*1.96 
  ci99_low  <- sample_means - sample_stderrs*2.58
  ci99_high <- sample_means + sample_stderrs*2.58
  
  # Visualize confidence intervals of all samples
  plot(NULL, xlim=c(pop_mean-(pop_sd/2), pop_mean+(pop_sd/2)), 
       ylim=c(1,num_samples), ylab="Samples", xlab="Confidence Intervals")
  add_ci_segment(ci95_low, ci95_high, ci99_low, ci99_high,
                 sample_means, 1:num_samples, good=TRUE)
  
  # Visualize samples with CIs that don't include population mean
  bad = which(((ci95_low > pop_mean) | (ci95_high < pop_mean)) |
              ((ci99_low > pop_mean) | (ci99_high < pop_mean)))
  add_ci_segment(ci95_low[bad], ci95_high[bad], ci99_low[bad], ci99_high[bad],
                 sample_means[bad], bad, good=FALSE)
  
  # Draw true population mean
  abline(v=mean(population_data))
}

add_ci_segment <- function(ci95_low, ci95_high, ci99_low, ci99_high, 
                           sample_means, indices, good=TRUE) {
  segment_colors <- list(c("lightcoral", "coral3", "coral4"),
                         c("lightskyblue", "skyblue3", "skyblue4"))
  color <- segment_colors[[as.integer(good)+1]]
  
  segments(ci99_low, indices, ci99_high, indices, lwd=3, col=color[1])
  segments(ci95_low, indices, ci95_high, indices, lwd=3, col=color[2])
  points(sample_means, indices, pch=18, cex=0.6, col=color[3])
}
```

```{r}
visualize_sample_ci(num_samples = 100, sample_size = 100, pop_size=10000, distr_func=rnorm, mean=20, sd=3)
```

#### (i) How many samples do we expect to NOT include the population mean in its 95% CI?  
5

#### (ii) How many samples do we expect to NOT include the population mean in their 99% CI?  
1

### (b) Rerun the previous simulation with larger samples (sample_size=300)
```{r}
visualize_sample_ci(num_samples = 100, sample_size = 300, pop_size=10000, distr_func=rnorm, mean=20, sd=3)
```

#### (i) the size of each sample has increased, their 95% and 99% CI to become wider or narrower than before?  
narrower.  

#### (ii) How many samples (out of the 100) would we expect to NOT include the population mean in its 95% CI?  
5.  

### (c) ran the above two examples (a and b) using a uniformly distributed population, the answers to (a) and (b)?  
the number of samples expected to not include the population mean will more than (a) and (b).  
The population is more concentrated, around mean(bell-shaped), in normal distribution, so it's easier to get a sample within one range including mean.  

```{r}
visualize_sample_ci(num_samples = 100, sample_size = 100, pop_size=10000, distr_func=runif)
```
```{r}
visualize_sample_ci(num_samples = 100, sample_size = 300, pop_size=10000, distr_func=runif)
```


# Question 3

### (a) “average” booking time
```{r}
mean(minday)
```

#### (i) Estimate the population mean of minday, its standard error, and the 95% confidence interval (CI) of the sampling means
```{r}
#mean
mean_minday <- sum(minday)/length(minday)
mean_minday
```
```{r}
#standard deviation
std_minday <- (sum((minday - mean_minday) ** 2) / length(minday)-1)**(1/2)
std_minday
```
```{r}
#standard error
std_error_minday <- std_minday/sqrt(length(minday))
std_error_minday
```

```{r}
#CI
quantiles <- unname(quantile(minday, c(0.025, 0.975)))
CI <- c(quantiles[1], quantiles[2])
CI
```
#### (ii) Bootstrap to produce 2000 new samples from the original sample
```{r}
resample <- replicate(2000, sample(minday, replace = TRUE))
```

#### (iii) Visualize the means of the 2000 bootstrapped samples
```{r}
plot_resample_mean <- function(sample_i){
  abline(v=mean(sample_i), col=rgb(0.5, 0.0, 0.0, 0.02))
}
```
```{r}
plot(density(minday), col="blue", lwd=2, main="CI of mean")
apply(resample, 2, FUN=plot_resample_mean)

abline(v=mean(minday), lwd=1)
```


#### (iv) Estimate the 95% CI of the bootstrapped means.

```{r}
boots_means <- apply(resample, 2, mean)
```
```{r}
# the 95% CI of the bootstrapped means
quantile(boots_means, c(0.025, 0.975))
```

### (b) By what time of day, have half the new members of the day already arrived at their restaurant?

#### (i) Estimate the median of minday
```{r}
median(minday)
```
#### (ii) Visualize the medians of the 2000 bootstrapped samples
```{r}
plot_resample_median <- function(sample_i){
  abline(v=median(sample_i), col=rgb(0.0, 0.5, 0.0, 0.01))
}
```

```{r}
plot(density(minday), lwd=1, ylim=c(0, 0.009), main="medians of bootstrapped samples",col="red")

apply(resample, 2, plot_resample_median)

abline(v=median(minday), lwd=2)
```

#### (iii) Estimate the 95% CI of the bootstrapped medians.
```{r}
medians_boots <- apply(resample, 2, median)
```

```{r}
quantile(medians_boots, c(0.025, 0.975))
```


